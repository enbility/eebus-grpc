// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.2
// source: usecases/cs/lpc/service.proto

package lpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ControllableSystemLPCControl_ConsumptionLimit_FullMethodName                       = "/cs_lpc.ControllableSystemLPCControl/ConsumptionLimit"
	ControllableSystemLPCControl_SetConsumptionLimit_FullMethodName                    = "/cs_lpc.ControllableSystemLPCControl/SetConsumptionLimit"
	ControllableSystemLPCControl_PendingConsumptionLimit_FullMethodName                = "/cs_lpc.ControllableSystemLPCControl/PendingConsumptionLimit"
	ControllableSystemLPCControl_ApproveOrDenyConsumptionLimit_FullMethodName          = "/cs_lpc.ControllableSystemLPCControl/ApproveOrDenyConsumptionLimit"
	ControllableSystemLPCControl_FailsafeConsumptionActivePowerLimit_FullMethodName    = "/cs_lpc.ControllableSystemLPCControl/FailsafeConsumptionActivePowerLimit"
	ControllableSystemLPCControl_SetFailsafeConsumptionActivePowerLimit_FullMethodName = "/cs_lpc.ControllableSystemLPCControl/SetFailsafeConsumptionActivePowerLimit"
	ControllableSystemLPCControl_FailsafeDurationMinimum_FullMethodName                = "/cs_lpc.ControllableSystemLPCControl/FailsafeDurationMinimum"
	ControllableSystemLPCControl_SetFailsafeDurationMinimum_FullMethodName             = "/cs_lpc.ControllableSystemLPCControl/SetFailsafeDurationMinimum"
	ControllableSystemLPCControl_StartHeartbeat_FullMethodName                         = "/cs_lpc.ControllableSystemLPCControl/StartHeartbeat"
	ControllableSystemLPCControl_StopHeartbeat_FullMethodName                          = "/cs_lpc.ControllableSystemLPCControl/StopHeartbeat"
	ControllableSystemLPCControl_IsHeartbeatWithinDuration_FullMethodName              = "/cs_lpc.ControllableSystemLPCControl/IsHeartbeatWithinDuration"
	ControllableSystemLPCControl_ConsumptionNominalMax_FullMethodName                  = "/cs_lpc.ControllableSystemLPCControl/ConsumptionNominalMax"
	ControllableSystemLPCControl_SetConsumptionNominalMax_FullMethodName               = "/cs_lpc.ControllableSystemLPCControl/SetConsumptionNominalMax"
)

// ControllableSystemLPCControlClient is the client API for ControllableSystemLPCControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControllableSystemLPCControlClient interface {
	ConsumptionLimit(ctx context.Context, in *ConsumptionLimitRequest, opts ...grpc.CallOption) (*ConsumptionLimitResponse, error)
	SetConsumptionLimit(ctx context.Context, in *SetConsumptionLimitRequest, opts ...grpc.CallOption) (*SetConsumptionLimitResponse, error)
	PendingConsumptionLimit(ctx context.Context, in *PendingConsumptionLimitRequest, opts ...grpc.CallOption) (*PendingConsumptionLimitResponse, error)
	ApproveOrDenyConsumptionLimit(ctx context.Context, in *ApproveOrDenyConsumptionLimitRequest, opts ...grpc.CallOption) (*ApproveOrDenyConsumptionLimitResponse, error)
	FailsafeConsumptionActivePowerLimit(ctx context.Context, in *FailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*FailsafeConsumptionActivePowerLimitResponse, error)
	SetFailsafeConsumptionActivePowerLimit(ctx context.Context, in *SetFailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*SetFailsafeConsumptionActivePowerLimitResponse, error)
	FailsafeDurationMinimum(ctx context.Context, in *FailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*FailsafeDurationMinimumResponse, error)
	SetFailsafeDurationMinimum(ctx context.Context, in *SetFailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*SetFailsafeDurationMinimumResponse, error)
	StartHeartbeat(ctx context.Context, in *StartHeartbeatRequest, opts ...grpc.CallOption) (*StartHeartbeatResponse, error)
	StopHeartbeat(ctx context.Context, in *StopHeartbeatRequest, opts ...grpc.CallOption) (*StopHeartbeatResponse, error)
	IsHeartbeatWithinDuration(ctx context.Context, in *IsHeartbeatWithinDurationRequest, opts ...grpc.CallOption) (*IsHeartbeatWithinDurationResponse, error)
	ConsumptionNominalMax(ctx context.Context, in *ConsumptionNominalMaxRequest, opts ...grpc.CallOption) (*ConsumptionNominalMaxResponse, error)
	SetConsumptionNominalMax(ctx context.Context, in *SetConsumptionNominalMaxRequest, opts ...grpc.CallOption) (*SetConsumptionNominalMaxResponse, error)
}

type controllableSystemLPCControlClient struct {
	cc grpc.ClientConnInterface
}

func NewControllableSystemLPCControlClient(cc grpc.ClientConnInterface) ControllableSystemLPCControlClient {
	return &controllableSystemLPCControlClient{cc}
}

func (c *controllableSystemLPCControlClient) ConsumptionLimit(ctx context.Context, in *ConsumptionLimitRequest, opts ...grpc.CallOption) (*ConsumptionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsumptionLimitResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_ConsumptionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) SetConsumptionLimit(ctx context.Context, in *SetConsumptionLimitRequest, opts ...grpc.CallOption) (*SetConsumptionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetConsumptionLimitResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_SetConsumptionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) PendingConsumptionLimit(ctx context.Context, in *PendingConsumptionLimitRequest, opts ...grpc.CallOption) (*PendingConsumptionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PendingConsumptionLimitResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_PendingConsumptionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) ApproveOrDenyConsumptionLimit(ctx context.Context, in *ApproveOrDenyConsumptionLimitRequest, opts ...grpc.CallOption) (*ApproveOrDenyConsumptionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApproveOrDenyConsumptionLimitResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_ApproveOrDenyConsumptionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) FailsafeConsumptionActivePowerLimit(ctx context.Context, in *FailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*FailsafeConsumptionActivePowerLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailsafeConsumptionActivePowerLimitResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_FailsafeConsumptionActivePowerLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) SetFailsafeConsumptionActivePowerLimit(ctx context.Context, in *SetFailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*SetFailsafeConsumptionActivePowerLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetFailsafeConsumptionActivePowerLimitResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_SetFailsafeConsumptionActivePowerLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) FailsafeDurationMinimum(ctx context.Context, in *FailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*FailsafeDurationMinimumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailsafeDurationMinimumResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_FailsafeDurationMinimum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) SetFailsafeDurationMinimum(ctx context.Context, in *SetFailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*SetFailsafeDurationMinimumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetFailsafeDurationMinimumResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_SetFailsafeDurationMinimum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) StartHeartbeat(ctx context.Context, in *StartHeartbeatRequest, opts ...grpc.CallOption) (*StartHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartHeartbeatResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_StartHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) StopHeartbeat(ctx context.Context, in *StopHeartbeatRequest, opts ...grpc.CallOption) (*StopHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopHeartbeatResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_StopHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) IsHeartbeatWithinDuration(ctx context.Context, in *IsHeartbeatWithinDurationRequest, opts ...grpc.CallOption) (*IsHeartbeatWithinDurationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsHeartbeatWithinDurationResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_IsHeartbeatWithinDuration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) ConsumptionNominalMax(ctx context.Context, in *ConsumptionNominalMaxRequest, opts ...grpc.CallOption) (*ConsumptionNominalMaxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsumptionNominalMaxResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_ConsumptionNominalMax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllableSystemLPCControlClient) SetConsumptionNominalMax(ctx context.Context, in *SetConsumptionNominalMaxRequest, opts ...grpc.CallOption) (*SetConsumptionNominalMaxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetConsumptionNominalMaxResponse)
	err := c.cc.Invoke(ctx, ControllableSystemLPCControl_SetConsumptionNominalMax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllableSystemLPCControlServer is the server API for ControllableSystemLPCControl service.
// All implementations must embed UnimplementedControllableSystemLPCControlServer
// for forward compatibility.
type ControllableSystemLPCControlServer interface {
	ConsumptionLimit(context.Context, *ConsumptionLimitRequest) (*ConsumptionLimitResponse, error)
	SetConsumptionLimit(context.Context, *SetConsumptionLimitRequest) (*SetConsumptionLimitResponse, error)
	PendingConsumptionLimit(context.Context, *PendingConsumptionLimitRequest) (*PendingConsumptionLimitResponse, error)
	ApproveOrDenyConsumptionLimit(context.Context, *ApproveOrDenyConsumptionLimitRequest) (*ApproveOrDenyConsumptionLimitResponse, error)
	FailsafeConsumptionActivePowerLimit(context.Context, *FailsafeConsumptionActivePowerLimitRequest) (*FailsafeConsumptionActivePowerLimitResponse, error)
	SetFailsafeConsumptionActivePowerLimit(context.Context, *SetFailsafeConsumptionActivePowerLimitRequest) (*SetFailsafeConsumptionActivePowerLimitResponse, error)
	FailsafeDurationMinimum(context.Context, *FailsafeDurationMinimumRequest) (*FailsafeDurationMinimumResponse, error)
	SetFailsafeDurationMinimum(context.Context, *SetFailsafeDurationMinimumRequest) (*SetFailsafeDurationMinimumResponse, error)
	StartHeartbeat(context.Context, *StartHeartbeatRequest) (*StartHeartbeatResponse, error)
	StopHeartbeat(context.Context, *StopHeartbeatRequest) (*StopHeartbeatResponse, error)
	IsHeartbeatWithinDuration(context.Context, *IsHeartbeatWithinDurationRequest) (*IsHeartbeatWithinDurationResponse, error)
	ConsumptionNominalMax(context.Context, *ConsumptionNominalMaxRequest) (*ConsumptionNominalMaxResponse, error)
	SetConsumptionNominalMax(context.Context, *SetConsumptionNominalMaxRequest) (*SetConsumptionNominalMaxResponse, error)
	mustEmbedUnimplementedControllableSystemLPCControlServer()
}

// UnimplementedControllableSystemLPCControlServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedControllableSystemLPCControlServer struct{}

func (UnimplementedControllableSystemLPCControlServer) ConsumptionLimit(context.Context, *ConsumptionLimitRequest) (*ConsumptionLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsumptionLimit not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) SetConsumptionLimit(context.Context, *SetConsumptionLimitRequest) (*SetConsumptionLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConsumptionLimit not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) PendingConsumptionLimit(context.Context, *PendingConsumptionLimitRequest) (*PendingConsumptionLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PendingConsumptionLimit not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) ApproveOrDenyConsumptionLimit(context.Context, *ApproveOrDenyConsumptionLimitRequest) (*ApproveOrDenyConsumptionLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveOrDenyConsumptionLimit not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) FailsafeConsumptionActivePowerLimit(context.Context, *FailsafeConsumptionActivePowerLimitRequest) (*FailsafeConsumptionActivePowerLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailsafeConsumptionActivePowerLimit not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) SetFailsafeConsumptionActivePowerLimit(context.Context, *SetFailsafeConsumptionActivePowerLimitRequest) (*SetFailsafeConsumptionActivePowerLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFailsafeConsumptionActivePowerLimit not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) FailsafeDurationMinimum(context.Context, *FailsafeDurationMinimumRequest) (*FailsafeDurationMinimumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailsafeDurationMinimum not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) SetFailsafeDurationMinimum(context.Context, *SetFailsafeDurationMinimumRequest) (*SetFailsafeDurationMinimumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFailsafeDurationMinimum not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) StartHeartbeat(context.Context, *StartHeartbeatRequest) (*StartHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartHeartbeat not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) StopHeartbeat(context.Context, *StopHeartbeatRequest) (*StopHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopHeartbeat not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) IsHeartbeatWithinDuration(context.Context, *IsHeartbeatWithinDurationRequest) (*IsHeartbeatWithinDurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsHeartbeatWithinDuration not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) ConsumptionNominalMax(context.Context, *ConsumptionNominalMaxRequest) (*ConsumptionNominalMaxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsumptionNominalMax not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) SetConsumptionNominalMax(context.Context, *SetConsumptionNominalMaxRequest) (*SetConsumptionNominalMaxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConsumptionNominalMax not implemented")
}
func (UnimplementedControllableSystemLPCControlServer) mustEmbedUnimplementedControllableSystemLPCControlServer() {
}
func (UnimplementedControllableSystemLPCControlServer) testEmbeddedByValue() {}

// UnsafeControllableSystemLPCControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControllableSystemLPCControlServer will
// result in compilation errors.
type UnsafeControllableSystemLPCControlServer interface {
	mustEmbedUnimplementedControllableSystemLPCControlServer()
}

func RegisterControllableSystemLPCControlServer(s grpc.ServiceRegistrar, srv ControllableSystemLPCControlServer) {
	// If the following call pancis, it indicates UnimplementedControllableSystemLPCControlServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ControllableSystemLPCControl_ServiceDesc, srv)
}

func _ControllableSystemLPCControl_ConsumptionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsumptionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).ConsumptionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_ConsumptionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).ConsumptionLimit(ctx, req.(*ConsumptionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_SetConsumptionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConsumptionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).SetConsumptionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_SetConsumptionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).SetConsumptionLimit(ctx, req.(*SetConsumptionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_PendingConsumptionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingConsumptionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).PendingConsumptionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_PendingConsumptionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).PendingConsumptionLimit(ctx, req.(*PendingConsumptionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_ApproveOrDenyConsumptionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveOrDenyConsumptionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).ApproveOrDenyConsumptionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_ApproveOrDenyConsumptionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).ApproveOrDenyConsumptionLimit(ctx, req.(*ApproveOrDenyConsumptionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_FailsafeConsumptionActivePowerLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailsafeConsumptionActivePowerLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).FailsafeConsumptionActivePowerLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_FailsafeConsumptionActivePowerLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).FailsafeConsumptionActivePowerLimit(ctx, req.(*FailsafeConsumptionActivePowerLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_SetFailsafeConsumptionActivePowerLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFailsafeConsumptionActivePowerLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).SetFailsafeConsumptionActivePowerLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_SetFailsafeConsumptionActivePowerLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).SetFailsafeConsumptionActivePowerLimit(ctx, req.(*SetFailsafeConsumptionActivePowerLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_FailsafeDurationMinimum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailsafeDurationMinimumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).FailsafeDurationMinimum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_FailsafeDurationMinimum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).FailsafeDurationMinimum(ctx, req.(*FailsafeDurationMinimumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_SetFailsafeDurationMinimum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFailsafeDurationMinimumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).SetFailsafeDurationMinimum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_SetFailsafeDurationMinimum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).SetFailsafeDurationMinimum(ctx, req.(*SetFailsafeDurationMinimumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_StartHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).StartHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_StartHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).StartHeartbeat(ctx, req.(*StartHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_StopHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).StopHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_StopHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).StopHeartbeat(ctx, req.(*StopHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_IsHeartbeatWithinDuration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsHeartbeatWithinDurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).IsHeartbeatWithinDuration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_IsHeartbeatWithinDuration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).IsHeartbeatWithinDuration(ctx, req.(*IsHeartbeatWithinDurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_ConsumptionNominalMax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsumptionNominalMaxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).ConsumptionNominalMax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_ConsumptionNominalMax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).ConsumptionNominalMax(ctx, req.(*ConsumptionNominalMaxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllableSystemLPCControl_SetConsumptionNominalMax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConsumptionNominalMaxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllableSystemLPCControlServer).SetConsumptionNominalMax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ControllableSystemLPCControl_SetConsumptionNominalMax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllableSystemLPCControlServer).SetConsumptionNominalMax(ctx, req.(*SetConsumptionNominalMaxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ControllableSystemLPCControl_ServiceDesc is the grpc.ServiceDesc for ControllableSystemLPCControl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ControllableSystemLPCControl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cs_lpc.ControllableSystemLPCControl",
	HandlerType: (*ControllableSystemLPCControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConsumptionLimit",
			Handler:    _ControllableSystemLPCControl_ConsumptionLimit_Handler,
		},
		{
			MethodName: "SetConsumptionLimit",
			Handler:    _ControllableSystemLPCControl_SetConsumptionLimit_Handler,
		},
		{
			MethodName: "PendingConsumptionLimit",
			Handler:    _ControllableSystemLPCControl_PendingConsumptionLimit_Handler,
		},
		{
			MethodName: "ApproveOrDenyConsumptionLimit",
			Handler:    _ControllableSystemLPCControl_ApproveOrDenyConsumptionLimit_Handler,
		},
		{
			MethodName: "FailsafeConsumptionActivePowerLimit",
			Handler:    _ControllableSystemLPCControl_FailsafeConsumptionActivePowerLimit_Handler,
		},
		{
			MethodName: "SetFailsafeConsumptionActivePowerLimit",
			Handler:    _ControllableSystemLPCControl_SetFailsafeConsumptionActivePowerLimit_Handler,
		},
		{
			MethodName: "FailsafeDurationMinimum",
			Handler:    _ControllableSystemLPCControl_FailsafeDurationMinimum_Handler,
		},
		{
			MethodName: "SetFailsafeDurationMinimum",
			Handler:    _ControllableSystemLPCControl_SetFailsafeDurationMinimum_Handler,
		},
		{
			MethodName: "StartHeartbeat",
			Handler:    _ControllableSystemLPCControl_StartHeartbeat_Handler,
		},
		{
			MethodName: "StopHeartbeat",
			Handler:    _ControllableSystemLPCControl_StopHeartbeat_Handler,
		},
		{
			MethodName: "IsHeartbeatWithinDuration",
			Handler:    _ControllableSystemLPCControl_IsHeartbeatWithinDuration_Handler,
		},
		{
			MethodName: "ConsumptionNominalMax",
			Handler:    _ControllableSystemLPCControl_ConsumptionNominalMax_Handler,
		},
		{
			MethodName: "SetConsumptionNominalMax",
			Handler:    _ControllableSystemLPCControl_SetConsumptionNominalMax_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usecases/cs/lpc/service.proto",
}
