// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.2
// source: usecases/eg/lpc/service.proto

package lpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EnergyGuardLPCControl_ConsumptionLimit_FullMethodName                         = "/eg_lpc.EnergyGuardLPCControl/ConsumptionLimit"
	EnergyGuardLPCControl_WriteConsumptionLimit_FullMethodName                    = "/eg_lpc.EnergyGuardLPCControl/WriteConsumptionLimit"
	EnergyGuardLPCControl_FailsafeConsumptionActivePowerLimit_FullMethodName      = "/eg_lpc.EnergyGuardLPCControl/FailsafeConsumptionActivePowerLimit"
	EnergyGuardLPCControl_WriteFailsafeConsumptionActivePowerLimit_FullMethodName = "/eg_lpc.EnergyGuardLPCControl/WriteFailsafeConsumptionActivePowerLimit"
	EnergyGuardLPCControl_FailsafeDurationMinimum_FullMethodName                  = "/eg_lpc.EnergyGuardLPCControl/FailsafeDurationMinimum"
	EnergyGuardLPCControl_WriteFailsafeDurationMinimum_FullMethodName             = "/eg_lpc.EnergyGuardLPCControl/WriteFailsafeDurationMinimum"
	EnergyGuardLPCControl_StartHeartbeat_FullMethodName                           = "/eg_lpc.EnergyGuardLPCControl/StartHeartbeat"
	EnergyGuardLPCControl_StopHeartbeat_FullMethodName                            = "/eg_lpc.EnergyGuardLPCControl/StopHeartbeat"
	EnergyGuardLPCControl_IsHeartbeatWithinDuration_FullMethodName                = "/eg_lpc.EnergyGuardLPCControl/IsHeartbeatWithinDuration"
	EnergyGuardLPCControl_ConsumptionNominalMax_FullMethodName                    = "/eg_lpc.EnergyGuardLPCControl/ConsumptionNominalMax"
)

// EnergyGuardLPCControlClient is the client API for EnergyGuardLPCControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnergyGuardLPCControlClient interface {
	ConsumptionLimit(ctx context.Context, in *ConsumptionLimitRequest, opts ...grpc.CallOption) (*ConsumptionLimitResponse, error)
	WriteConsumptionLimit(ctx context.Context, in *WriteConsumptionLimitRequest, opts ...grpc.CallOption) (*WriteConsumptionLimitResponse, error)
	FailsafeConsumptionActivePowerLimit(ctx context.Context, in *FailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*FailsafeConsumptionActivePowerLimitResponse, error)
	WriteFailsafeConsumptionActivePowerLimit(ctx context.Context, in *WriteFailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*WriteFailsafeConsumptionActivePowerLimitResponse, error)
	FailsafeDurationMinimum(ctx context.Context, in *FailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*FailsafeDurationMinimumResponse, error)
	WriteFailsafeDurationMinimum(ctx context.Context, in *WriteFailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*WriteFailsafeDurationMinimumResponse, error)
	StartHeartbeat(ctx context.Context, in *StartHeartbeatRequest, opts ...grpc.CallOption) (*StartHeartbeatResponse, error)
	StopHeartbeat(ctx context.Context, in *StopHeartbeatRequest, opts ...grpc.CallOption) (*StopHeartbeatResponse, error)
	IsHeartbeatWithinDuration(ctx context.Context, in *IsHeartbeatWithinDurationRequest, opts ...grpc.CallOption) (*IsHeartbeatWithinDurationResponse, error)
	ConsumptionNominalMax(ctx context.Context, in *ConsumptionNominalMaxRequest, opts ...grpc.CallOption) (*ConsumptionNominalMaxResponse, error)
}

type energyGuardLPCControlClient struct {
	cc grpc.ClientConnInterface
}

func NewEnergyGuardLPCControlClient(cc grpc.ClientConnInterface) EnergyGuardLPCControlClient {
	return &energyGuardLPCControlClient{cc}
}

func (c *energyGuardLPCControlClient) ConsumptionLimit(ctx context.Context, in *ConsumptionLimitRequest, opts ...grpc.CallOption) (*ConsumptionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsumptionLimitResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_ConsumptionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) WriteConsumptionLimit(ctx context.Context, in *WriteConsumptionLimitRequest, opts ...grpc.CallOption) (*WriteConsumptionLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteConsumptionLimitResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_WriteConsumptionLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) FailsafeConsumptionActivePowerLimit(ctx context.Context, in *FailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*FailsafeConsumptionActivePowerLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailsafeConsumptionActivePowerLimitResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_FailsafeConsumptionActivePowerLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) WriteFailsafeConsumptionActivePowerLimit(ctx context.Context, in *WriteFailsafeConsumptionActivePowerLimitRequest, opts ...grpc.CallOption) (*WriteFailsafeConsumptionActivePowerLimitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteFailsafeConsumptionActivePowerLimitResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_WriteFailsafeConsumptionActivePowerLimit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) FailsafeDurationMinimum(ctx context.Context, in *FailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*FailsafeDurationMinimumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailsafeDurationMinimumResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_FailsafeDurationMinimum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) WriteFailsafeDurationMinimum(ctx context.Context, in *WriteFailsafeDurationMinimumRequest, opts ...grpc.CallOption) (*WriteFailsafeDurationMinimumResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WriteFailsafeDurationMinimumResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_WriteFailsafeDurationMinimum_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) StartHeartbeat(ctx context.Context, in *StartHeartbeatRequest, opts ...grpc.CallOption) (*StartHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartHeartbeatResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_StartHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) StopHeartbeat(ctx context.Context, in *StopHeartbeatRequest, opts ...grpc.CallOption) (*StopHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopHeartbeatResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_StopHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) IsHeartbeatWithinDuration(ctx context.Context, in *IsHeartbeatWithinDurationRequest, opts ...grpc.CallOption) (*IsHeartbeatWithinDurationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsHeartbeatWithinDurationResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_IsHeartbeatWithinDuration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *energyGuardLPCControlClient) ConsumptionNominalMax(ctx context.Context, in *ConsumptionNominalMaxRequest, opts ...grpc.CallOption) (*ConsumptionNominalMaxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsumptionNominalMaxResponse)
	err := c.cc.Invoke(ctx, EnergyGuardLPCControl_ConsumptionNominalMax_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EnergyGuardLPCControlServer is the server API for EnergyGuardLPCControl service.
// All implementations must embed UnimplementedEnergyGuardLPCControlServer
// for forward compatibility.
type EnergyGuardLPCControlServer interface {
	ConsumptionLimit(context.Context, *ConsumptionLimitRequest) (*ConsumptionLimitResponse, error)
	WriteConsumptionLimit(context.Context, *WriteConsumptionLimitRequest) (*WriteConsumptionLimitResponse, error)
	FailsafeConsumptionActivePowerLimit(context.Context, *FailsafeConsumptionActivePowerLimitRequest) (*FailsafeConsumptionActivePowerLimitResponse, error)
	WriteFailsafeConsumptionActivePowerLimit(context.Context, *WriteFailsafeConsumptionActivePowerLimitRequest) (*WriteFailsafeConsumptionActivePowerLimitResponse, error)
	FailsafeDurationMinimum(context.Context, *FailsafeDurationMinimumRequest) (*FailsafeDurationMinimumResponse, error)
	WriteFailsafeDurationMinimum(context.Context, *WriteFailsafeDurationMinimumRequest) (*WriteFailsafeDurationMinimumResponse, error)
	StartHeartbeat(context.Context, *StartHeartbeatRequest) (*StartHeartbeatResponse, error)
	StopHeartbeat(context.Context, *StopHeartbeatRequest) (*StopHeartbeatResponse, error)
	IsHeartbeatWithinDuration(context.Context, *IsHeartbeatWithinDurationRequest) (*IsHeartbeatWithinDurationResponse, error)
	ConsumptionNominalMax(context.Context, *ConsumptionNominalMaxRequest) (*ConsumptionNominalMaxResponse, error)
	mustEmbedUnimplementedEnergyGuardLPCControlServer()
}

// UnimplementedEnergyGuardLPCControlServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEnergyGuardLPCControlServer struct{}

func (UnimplementedEnergyGuardLPCControlServer) ConsumptionLimit(context.Context, *ConsumptionLimitRequest) (*ConsumptionLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsumptionLimit not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) WriteConsumptionLimit(context.Context, *WriteConsumptionLimitRequest) (*WriteConsumptionLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteConsumptionLimit not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) FailsafeConsumptionActivePowerLimit(context.Context, *FailsafeConsumptionActivePowerLimitRequest) (*FailsafeConsumptionActivePowerLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailsafeConsumptionActivePowerLimit not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) WriteFailsafeConsumptionActivePowerLimit(context.Context, *WriteFailsafeConsumptionActivePowerLimitRequest) (*WriteFailsafeConsumptionActivePowerLimitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteFailsafeConsumptionActivePowerLimit not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) FailsafeDurationMinimum(context.Context, *FailsafeDurationMinimumRequest) (*FailsafeDurationMinimumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailsafeDurationMinimum not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) WriteFailsafeDurationMinimum(context.Context, *WriteFailsafeDurationMinimumRequest) (*WriteFailsafeDurationMinimumResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteFailsafeDurationMinimum not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) StartHeartbeat(context.Context, *StartHeartbeatRequest) (*StartHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartHeartbeat not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) StopHeartbeat(context.Context, *StopHeartbeatRequest) (*StopHeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopHeartbeat not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) IsHeartbeatWithinDuration(context.Context, *IsHeartbeatWithinDurationRequest) (*IsHeartbeatWithinDurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsHeartbeatWithinDuration not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) ConsumptionNominalMax(context.Context, *ConsumptionNominalMaxRequest) (*ConsumptionNominalMaxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsumptionNominalMax not implemented")
}
func (UnimplementedEnergyGuardLPCControlServer) mustEmbedUnimplementedEnergyGuardLPCControlServer() {}
func (UnimplementedEnergyGuardLPCControlServer) testEmbeddedByValue()                               {}

// UnsafeEnergyGuardLPCControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnergyGuardLPCControlServer will
// result in compilation errors.
type UnsafeEnergyGuardLPCControlServer interface {
	mustEmbedUnimplementedEnergyGuardLPCControlServer()
}

func RegisterEnergyGuardLPCControlServer(s grpc.ServiceRegistrar, srv EnergyGuardLPCControlServer) {
	// If the following call pancis, it indicates UnimplementedEnergyGuardLPCControlServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EnergyGuardLPCControl_ServiceDesc, srv)
}

func _EnergyGuardLPCControl_ConsumptionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsumptionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).ConsumptionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_ConsumptionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).ConsumptionLimit(ctx, req.(*ConsumptionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_WriteConsumptionLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteConsumptionLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).WriteConsumptionLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_WriteConsumptionLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).WriteConsumptionLimit(ctx, req.(*WriteConsumptionLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_FailsafeConsumptionActivePowerLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailsafeConsumptionActivePowerLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).FailsafeConsumptionActivePowerLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_FailsafeConsumptionActivePowerLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).FailsafeConsumptionActivePowerLimit(ctx, req.(*FailsafeConsumptionActivePowerLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_WriteFailsafeConsumptionActivePowerLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFailsafeConsumptionActivePowerLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).WriteFailsafeConsumptionActivePowerLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_WriteFailsafeConsumptionActivePowerLimit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).WriteFailsafeConsumptionActivePowerLimit(ctx, req.(*WriteFailsafeConsumptionActivePowerLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_FailsafeDurationMinimum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailsafeDurationMinimumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).FailsafeDurationMinimum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_FailsafeDurationMinimum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).FailsafeDurationMinimum(ctx, req.(*FailsafeDurationMinimumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_WriteFailsafeDurationMinimum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteFailsafeDurationMinimumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).WriteFailsafeDurationMinimum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_WriteFailsafeDurationMinimum_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).WriteFailsafeDurationMinimum(ctx, req.(*WriteFailsafeDurationMinimumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_StartHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).StartHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_StartHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).StartHeartbeat(ctx, req.(*StartHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_StopHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).StopHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_StopHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).StopHeartbeat(ctx, req.(*StopHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_IsHeartbeatWithinDuration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsHeartbeatWithinDurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).IsHeartbeatWithinDuration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_IsHeartbeatWithinDuration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).IsHeartbeatWithinDuration(ctx, req.(*IsHeartbeatWithinDurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnergyGuardLPCControl_ConsumptionNominalMax_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsumptionNominalMaxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnergyGuardLPCControlServer).ConsumptionNominalMax(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnergyGuardLPCControl_ConsumptionNominalMax_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnergyGuardLPCControlServer).ConsumptionNominalMax(ctx, req.(*ConsumptionNominalMaxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EnergyGuardLPCControl_ServiceDesc is the grpc.ServiceDesc for EnergyGuardLPCControl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnergyGuardLPCControl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eg_lpc.EnergyGuardLPCControl",
	HandlerType: (*EnergyGuardLPCControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConsumptionLimit",
			Handler:    _EnergyGuardLPCControl_ConsumptionLimit_Handler,
		},
		{
			MethodName: "WriteConsumptionLimit",
			Handler:    _EnergyGuardLPCControl_WriteConsumptionLimit_Handler,
		},
		{
			MethodName: "FailsafeConsumptionActivePowerLimit",
			Handler:    _EnergyGuardLPCControl_FailsafeConsumptionActivePowerLimit_Handler,
		},
		{
			MethodName: "WriteFailsafeConsumptionActivePowerLimit",
			Handler:    _EnergyGuardLPCControl_WriteFailsafeConsumptionActivePowerLimit_Handler,
		},
		{
			MethodName: "FailsafeDurationMinimum",
			Handler:    _EnergyGuardLPCControl_FailsafeDurationMinimum_Handler,
		},
		{
			MethodName: "WriteFailsafeDurationMinimum",
			Handler:    _EnergyGuardLPCControl_WriteFailsafeDurationMinimum_Handler,
		},
		{
			MethodName: "StartHeartbeat",
			Handler:    _EnergyGuardLPCControl_StartHeartbeat_Handler,
		},
		{
			MethodName: "StopHeartbeat",
			Handler:    _EnergyGuardLPCControl_StopHeartbeat_Handler,
		},
		{
			MethodName: "IsHeartbeatWithinDuration",
			Handler:    _EnergyGuardLPCControl_IsHeartbeatWithinDuration_Handler,
		},
		{
			MethodName: "ConsumptionNominalMax",
			Handler:    _EnergyGuardLPCControl_ConsumptionNominalMax_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usecases/eg/lpc/service.proto",
}
